($define-ground-lambda! write-simple (x . r)
  ($let1 p ($if (null? r) stdout (car r))
    (write-shared
      x
      (list (shared-structure-indicator #inert))
      p)
    (flush-output-port p)))

($define-ground-lambda! write (x . r)
  ($let1 p ($if (null? r) stdout (car r))
    (write-aux
      x
      (list (shared-structure-indicator x) () 0)
      p)
    (flush-output-port p)))

($defun-privates!
  (write-shared (x s p)
    ($if ((car s) x)
      ($sequence
        ($define! (#ignore a n) s)
        ($define! z (assq x a))
        (write-char #\# p)
        ($if (pair? z)
          ($sequence
            (write-number (cdr z) 10 p)
            (write-char #\# p))
          ($sequence
            (write-number n 10 p)
            (write-char #\= p)
            (set-car! (list-tail s 1) (cons (cons x n) a))
            (set-car! (list-tail s 2) (+ 1 n))
            (write-aux x s p))))
      (write-aux x s p)))
  (write-aux (x s p)
    ($cond
      ((pair? x)
        (write-char #\( p)
        (write-shared (car x) s p)
        (write-tail (cdr x) s p))
      ((number? x)
        ($cond
          ((fixint? x)
            (write-number x 10 p))
          ((bigint? x)
            (write-string "#[bigint]" p)) ;; TODO
          (#t
            (write-string
              ($if (positive? x) "#e+infinity" "#e-infinity")
              p))))
      ((inert? x)
        (write-string "#inert" p))
      ((ignore? x)
        (write-string "#ignore" p))
      ((null? x)
        (write-string "()" p))
      ((string? x)
        (write-char #\" p)
        (write-string-data (open-input-string x) p)
        (write-char #\" p))
      ((symbol? x)
        (write-string-like-symbol (symbol->string x) p))
      ((keyword? x)
        (write-string "#:" p)
        (write-string-like-symbol (keyword->string x) p))
      ((char? x)
        (write-string "#\\" p)
        (write-char-char x p))
      ((eq? x #t)
        (write-string "#t" p))
      ((eq? x #f)
        (write-string "#f" p))
      ((eof-object? x)
        (write-string "#[eof]" p))
      ((applicative? x)
        (write-string "#[applicative]" p))
      ((operative? x)
        (write-string "#[operative]" p))
      ((environment? x)
        (write-string "#[environment]" p))
      ((port? x)
        (write-string "#[port]" p))
      ((continuation? x)
        (write-string "#[continuation]" p))
      ((vector? x)
        (write-string "#[vector]" p))
      ((error-object? x)
        (write-string "#[error " p)
        (write-shared (error-object-message x) s p)
        (write-string "]" p))
      (#t (write-string "#[encapsulation]" p))))
  (write-tail (x s p)
    ($cond
      ((null? x)
        (write-char #\) p))
      (($and? (pair? x) (not? ((car s) x)))
        (write-char #\space p)
        (write-shared (car x) s p)
        (write-tail (cdr x) s p))
      (#t
        (write-string " . " p)
        (write-shared x s p)
        (write-char #\) p))))
  (write-char-char (c p)
    ($cond
      ((eq? c #\newline) (write-string "newline" p))
      ((eq? c #\space) (write-string "space" p))
      ((char<=? #\newline c #\x7D) (write-char c p))
      (#t
        (write-char #\x p)
        (write-string (number-digits (char->integer c) 16) p))))
  (write-string-char (c p)
    ($cond
      ((eq? c #\\) (write-string "\\\\" p))
      ((eq? c #\") (write-string "\\\"" p))
      ((char<=? #\x20 c #\x7D) (write-char c p))
      ((eq? c #\newline) (write-string "\\n" p))
      (#t
        (write-string "\\x" p)
        (write-string (number-digits (char->integer c) 16) p)
        (write-char #\; p))))
  (write-string-data (p q)
    ($let1 c (read-char p)
      ($unless (eof-object? c)
        (write-string-char c q)
        (write-string-data p q))))
  (write-number (n b p)
    ($if (<? n 0)
      ($sequence
        (write-char #\- p)
        (write-string (number-digits (- 0 n) b) p))
      (write-string (number-digits n b) p)))
  (write-string-like-symbol (s p)
    ($if (simple-string? (open-input-string s))
      (write-string s p)
      ($sequence
        (write-char #\| p)
        (write-string-data (open-input-string s) p)
        (write-char #\| p))))
  (simple-string-tail? (p)
    ($let1 c (read-char p)
      ($or?
        (eof-object? c)
        ($and? ($or? (char-alphabetic? c)
                     (char<=? #\0 c #\9)
                     (memq? c extended-identifier-characters))
               (simple-string-tail? p)))))
  (simple-string? (p)
    ($let1 c (read-char p)
      ($cond
        ((eq? c #\.)
          ($and? (not? (eof-object? (peek-char p)))
                 (simple-string-tail? p)))
        (#t
          ($and?
            (char? c)
            ($or? (char-alphabetic? c)
                  (memq? c extended-identifier-characters))
            (simple-string-tail? p)))))))

($bind-private! number-digits
  (make-bounded-applicative
    (list 2 2) (list "app_number_digits.A2") ()))

($define-ground-lambda! number->string (x . r)
  ($let1 p (open-output-string)
    (write-number x ($if (pair? r) (car r) 10) p)
    (get-output-string p)))

($define-ground-lambda! newline r
  ($let1 p ($if (pair? r) (car r) stdout)
    (write-char #\newline p)
    (flush-output-port p)))
