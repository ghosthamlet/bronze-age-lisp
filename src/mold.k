;;;
;;; mold.k
;;;
;;; Prints assembly source code of the interpreter.
;;;

;;
;; ($quote OBJ) => OBJ
;; ($quote* X1 X2 ... Xn) => (X1 X2 ... Xn)
;;
($define! $quote ($vau (x) #ignore x))
($define! $quote* ($vau x #ignore x))

;;
;; (set! ENVIRONMENT SYMBOL VALUE)
;; (binds? ENVIRONMENT SYMBOL...)
;;
;; Applicative form of standard operatives $set! and $binds?
;;
($provide! (set! binds?)
  ($define! set!
    ($lambda (env sym val)
      (eval (list $define! sym (cons $quote* val)) env)))
  ($define! binds?
    (wrap $binds?)))

;;
;; (split-arg STRING) => (STRING STRING)
;;
;; Split a string of the form "KEY=VALUE" into KEY and VALUE
;; parts. The KEY is the empty string, if #\= is not present
;; in the input.
;;
($provide! (split-arg)
  ($define! find
    ($lambda (x acc)
      ($cond
        ((null? x) (list () (reverse acc)))
        ((char=? (car x) #\=) (list (reverse acc) (cdr x)))
        (#t (find (cdr x) (cons (car x) acc))))))
  ($define! split-arg
    ($lambda (arg)
      (map list->string (find (string->list arg) ())))))

;;
;; (parse-command-line STRICT)
;;
;; Parse command line options and modify configuration.
;; Signal errors only if STRICT = #t.
;;
($define! parse-command-line
  ($lambda (strict)
    (for-each
      ($lambda (arg)
        ($define! (key value) (split-arg arg))
        ($if (string=? key "")
          ($when strict
            (print-usage)
            (exit 1))
          ($sequence
            ($define! key (string->symbol key))
            ($if (binds? configuration key)
              (set! configuration key (read (open-input-string value)))
              ($when strict
                (error "unknown configuration argument" arg))))))
      (cdr (get-script-arguments)))))

;;
;; Define preliminary configuration environment and parse
;; command line for the first time. If the command line
;; overrides src-path, we load configuration from
;; the specified diractory.
;;
($define! configuration ($bindings->environment (src-prefix "")))
(parse-command-line #f)

;;
;; ($for-each-src COMBINER PREFIX1 PREFIX2 . ARGS)
;;
;; For all arguments, apply COMBINER to concatenation of
;;
;;  ($configured PREFIX1) PREFIX2 ARGUMENT
;;
;;
($define! $for-each-src
  ($vau (combiner prefix1 prefix2 . args) denv
    ($let*
      ((c (eval combiner denv))
       (p (string-append (eval prefix1 configuration) (eval prefix2 denv)))
       (f ($lambda (a) (string-append p (eval a denv)))))
      (apply for-each (list c (map f args)) denv))))

;; Load configuration.
($for-each-src load src-prefix ""
  "utilities.k"
  "configuration.k"
  "assembly.k")

;; print command line help
($define! print-usage
  ($lambda ()
    (display "usage: klisp mold.k ['PARAM=VALUE' ...] > OUT.asm\n")
    (display "parameters:\n\n")
    (for-each
      ($lambda ((sym val help))
        (display (string-append* "  " sym " = "))
        (write val)
        (display (string-append* "\n    " help "\n\n")))
      configuration-help)))

;; Now we have default configuration parameters. Let command
;; line arguments override it.
(parse-command-line #t)
(check-configuration)

;; load runtime
($for-each-src load src-prefix "runtime/"
  "types.k"
  "error-messages.k"
  "rom-blobs.k"
  "data-segments.k"
  "applicatives.k"
  "mark-bits.k"
  "platform.k")

;; load primitives
($for-each-src load src-prefix "modules/"
  "predicates.k"
  "primitives.k"
  "pairs.k"
  "lists.k"
  "iterations.k"
  "environments.k"
  ;"characters.k"
  "continuations.k"
  "promises.k"
  "numbers.k"
  "signals.k"
  "system.k"
  "libraries.k"
  "_provisional.k"
  )

($when ($configured reader-and-printer)
  ($for-each-src load src-prefix "modules/"
    "ports.k"
    "printer.k"
    "reader.k"
    "repl.k"
    "tui.k"))

;; add version string and user bindings
($bind-ground! interpreter-version "Bronze Age Lisp 0.1")
(for-each
  ($lambda (x) (apply bind-ground! x))
  ($configured user-ground-bindings))

;; assembly output header
(display ";;;\n;;; generated by mold.k, do not change manually\n;;;\n")
(display ";;; configuration parameters:\n")
(for-each
  ($lambda ((sym . #ignore))
    (display (string-append* ";;;   " sym " = "))
    (write ((wrap $configured) sym))
    (newline))
  configuration-help)

;; constants and macros
($unless ($configured no-macros)
  (asm)
  (asm-comment "make configuration values available in assembly language")
  (for-each
    ($lambda ((sym . #ignore))
      ($let*
        ((v ((wrap $configured) sym))
         (w ($cond
              ((boolean? v) ($if v 1 0))
              ((integer? v) v)
              (#t "LISP_VALUE")))
         (i (asm-identifier "configured_" sym)))
        (asm "%define" i w)))
    configuration-help)
  (emit-type-macros)
  ($for-each-src asm-include asm-prefix "runtime/"
    "types.asm"))

;; define data and bss segments
($define! rodata-size
  ($if ($configured no-data-segment)
    256 ; testing only
    ($sequence
      (asm "section .bss")
      ($for-each-src asm-include asm-prefix "runtime/" "bss.asm")
      (emit-data-segments))))

($unless ($configured no-macros)
  (emit-mark-bit-macros rodata-size))

;; include implementation files
($unless ($configured no-code-segment)
  (asm)
  (asm "section .text")
  (asm "program_segment_base: nop")
  (asm "align 4")
  ($for-each-src asm-include asm-prefix "runtime/"
    "debug.asm"
    "utf8.asm"
    "list-metrics.asm"
    "continuation-ancestry.asm"
    "lisp-allocator.asm"
    "lisp-garbage.asm"
    "blob-data.asm"
    "blob-allocator.asm"
    "blob-garbage.asm"
    "blob-bits.asm"
    "blob-zero.asm"
    "critbit.asm"
    "list-construction.asm"
    "environment-lookup.asm"
    "environment-mutations.asm"
    "evaluator.asm"
    "applicatives.asm"
    "interpreted-operatives.asm"
    "guarded-continuations.asm"
    "mark-bits.asm"
    "equality.asm"
    "deep-copies.asm"
    "parameter-trees.asm"
    "runtime-errors.asm"
    "bigints.asm"
    "object-names.asm"
    "platform-initialization.asm"
    "platform-ports.asm"
    "platform-signals.asm"))

($unless ($configured no-applicative-support)
  (emit-applicative-support))


($unless ($configured no-code-segment)
  ($for-each-src asm-include asm-prefix "modules/"
    "predicates.asm"
    "bitwise-operations.asm"
    "booleans.asm"
    "characters.asm"
    "combiners.asm"
    "continuations.asm"
    "control.asm"
    "encapsulations.asm"
    "environments.asm"
    "errors.asm"
    "iterations.asm"
    "keyed-variables.asm"
    "lists.asm"
    "libraries.asm"
    "misc.asm"
    "numbers.asm"
    "pairs.asm"
    "ports.asm"
    "promises.asm"
    "strings.asm"
    "shared-structures.asm"
    "signals.asm"
    "symbols.asm"
    "system.asm"
    "vectors.asm")
  ($when ($configured character-predicates)
    ($for-each-src asm-include asm-prefix "unicode/"
      "unicode-lookup.asm"
      "generated-code.asm"))
  (asm "program_segment_limit: nop"))
