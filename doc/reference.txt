
          ================================
          Bronze Age Lisp Reference Manual
          ================================

Part I - Ground bindings
========================

Abbreviations
-------------

  arguments and types:

    APPLICATIVE    applicative combiner
    BINDING        pair (PTREE VALUE)
    CONT           continuation
    ENV            environment
    FORM or BODY   any object
    GUARD          pair (CONTINUATION APPLICATIVE)
    INTEGER        integer number (finite number)
    LIST           list of objects
    NUM            number (integer or exact infinity)
    OBJECT or KEY  any object
    PTREE          formal parameter tree
    U8             byte (integer 0..255)
    [ X ] or ...   optional arguments
    Xs             list of X

  compatibility notes:

    klisp      the feature is compatible with klisp

    r5rs       the feature is taken from Scheme Report
    r7rs       ... from Scheme Report draft
    SRFI-NN    ... from Scheme Requests for Implementation

    ext        the feature is nonportable
               extension of Bronze Age Lisp

      Note that environments returned by
      (make-kernel-standard-environment)
      contain all bindings, even if they
      are not standard.

List of non-combiner ground bindings
------------------------------------

  error-continuation     ; CONT
  interpreter-version    ; STRING, ext
  root-continuation      ; CONT
  stderr                 ; PORT, ext
  stdin                  ; PORT, ext
  stdout                 ; PORT, ext

List of combiners bound in the ground environment
-------------------------------------------------

  (+ . NUMs)
  (- . NUMs)
  (* . NUMs)
  (<? . NUMs)
  (<=? . NUMs)
  (=? . NUMs)
  (>=? . NUMs)
  (>? . NUMs)

  (abs NUM)
  (and . FORMs)
  ($and . FORMs)
  (append! LIST . LISTs)
  (append . LISTs)
  (applicative? . OBJECTs)
  (apply-continuation CONT OBJECT)
  (apply APPLICATIVE OBJECT [ENV])
  (arithmetic-shift NUM NUM)                         ; SRFI-60
  (assoc KEY LIST)
  (assq KEY LIST)

  (bigint? . OBJECTs)                                ; ext
  (binary-port? . OBJECTs)                           ; klisp
  ($bindings->environment BINDINGs)
  ($binds? ENV . SYMBOLs)
  (bitwise-and . INTEGERs)                           ; SRFI-60
  (bitwise-ior . INTEGERs)                           ; SRFI-60
  (bitwise-not INTEGER)                              ; SRFI-60
  (boolean? . OBJECTs)
  (bytevector . U8s)                                 ; klisp
  (bytevector? . OBJECTs)                            ; klisp
  (bytevector<? . BYTEVECTORs)                       ; ext
  (bytevector<=? . BYTEVECTORs)                      ; ext
  (bytevector=? . BYTEVECTORs)                       ; r6rs
  (bytevector>=? . BYTEVECTORs)                      ; ext
  (bytevector>? . BYTEVECTORs)                       ; ext
  (bytevector-copy BYTEVECTOR)                       ; klisp, r7rs
  (bytevector-copy-partial BYTEVECTOR START END)     ; klisp, r7rs
  (bytevector-copy-partial! FROM START END TO AT)    ; klisp, r7rs
  (bytevector-length BYTEVECTOR)                     ; klisp, r7rs
  (bytevector->list BYTEVECTOR)                      ; klisp
  (bytevector-u8-ref BYTEVECTOR INDEX)               ; klisp, r7rs
  (bytevector-u8-set! BYTEVECTOR INDEX U8)           ; klisp, r7rs

  (caaar PAIR)
  (caaaar PAIR)
  (caaadr PAIR)
  (caaar PAIR)
  (caadar PAIR)
  (caaddr PAIR)
  (caadr PAIR)
  (caar PAIR)
  (cadaar PAIR)
  (cadadr PAIR)
  (cadar PAIR)
  (caddar PAIR)
  (cadddr PAIR)
  (caddr PAIR)
  (cadr PAIR)
  (call/cc APPLICATIVE)
  (call-with-input-file STRING COMBINER)
  (call-with-output-file STRING COMBINER)
  (call-with-port PORT COMBINER)                     ; ?
  (car PAIR)
  ($case-lambda (PTREE . BODY) ...)                  ; r7rs
  (cdaaar PAIR)
  (cdaadr PAIR)
  (cdaar PAIR)
  (cdadar PAIR)
  (cdaddr PAIR)
  (cdadr PAIR)
  (cdar PAIR)
  (cddaar PAIR)
  (cddadr PAIR)
  (cddar PAIR)
  (cdddar PAIR)
  (cddddr PAIR)
  (cdddr PAIR)
  (cddr PAIR)
  (cdr PAIR)
  (char? . OBJECTs)
  (char<? . CHARs)
  (char<=? . CHARs)
  (char=? . CHARs)
  (char>=? . CHARs)
  (char>? . CHARs)
  (char-alphabetic? . CHARs)                         ; klisp
  (char->digit CHAR [RADIX])
  (char-digit? CHAR [RADIX])
  (char->integer CHAR)
  (char-ready? [PORT])
  (char-whitespace? . CHARs)                         ; klisp
  (close-input-port PORT)
  (close-output-port PORT)
  (close-port PORT)
  (close-port-ignore-errors PORT)                    ; ext
  (collect-garbage)                                  ; ext
  (color-port? PORT)                                 ; ext
  (combiner? . OBJECTs)
  ($cond (BOOLEAN . BODY) ...)
  (cons OBJECT OBJECT)
  (continuation->applicative CONT)
  (continuation? . OBJECTs)
  (copy-es OBJECT)
  (copy-es-immutable OBJECT)
  (countable-list? OBJECT)

  ($define! PTREE FORM)
  (defined-environment-variable? STRING)             ; klisp
  (delete-file STRING)                               ; r7rs
  (digit->char INTEGER RADIX)
  (disassemble-compiled-combiner COMBINER)           ; ext
  (display OBJECT [PORT])
  (div-and-mod INTEGER INTEGER)
  (div0-and-mod0 INTEGER INTEGER)
  (div INTEGER INTEGER)
  (div0 INTEGER INTEGER)
  (dup2 PORT/FIXINT FIXINT)                          ; ext

  (encycle! LIST INDEX INDEX)
  (environment? . OBJECTs)
  (eof-object? . OBJECTs)
  (eq? . OBJECTs)
  (equal? . OBJECTs)
  (error MESSAGE . IRRITANT-OBJECTs)                 ; klisp
  (error-object-message ERROR-OBJECT)                ; klisp
  (error-object-irritants ERROR-OBJECT)              ; klisp
  (error-object-source ERROR-OBJECT)                 ; ext
  (eval OBJECT ENV)
  (even? . NUMs)
  (execve PATH [ARGS [ENV]])                         ; ext
  (exit OBJECT)
  (extend-continuation CONT APPLICATIVE [ENV])

  (file-exists? . STRINGs)                           ; klisp
  (filter PREDICATE LIST)
  (find-required-filename STRING)                    ; klisp
  (finite-list? . OBJECTs)
  (fixint? . OBJECTs)                                ; ext
  (flush-output-port [PORT])
  (force PROMISE)
  (for-each APPLICATIVE . LISTs)
  (fork APPLICATIVE [CONTINUATION])                  ; ext
  (formal-parameter-tree? . OBJECTs)                 ; ext
  (format [PORT] STRING . OBJECTs)                   ; srfi-28

  (gcd . NUMs)
  (get-current-environment)
  (get-current-error-port)                           ; klisp
  (get-current-input-port)
  (get-current-jiffy)                                ; klisp
  (get-current-output-port)
  (get-current-second)                               ; klisp
  (get-environment-variable STRING)                  ; klisp
  (get-environment-variables)                        ; klisp
  (get-interpreter-arguments)                        ; klisp
  (get-library-environment LIBRARY)                  ; klisp
  (get-library-export-list LIBRARY)                  ; klisp
  (get-list-metrics OBJECT)
  (get-module FILENAME)
  (get-output-string STRING-PORT)                    ; r7rs
  (get-output-bytevector BYTEVECTOR-PORT)            ; r7rs
  (get-output-bytevector-position BYTEVECTOR-PORT)   ; ext
  (get-performance-statistics)                       ; ext
  (getpid)                                           ; ext
  ($get-printer-flag SYMBOL)                         ; ext
  ($get-registered-library LIBRARY-NAME)             ; klisp
  (get-script-arguments)                             ; klisp
  (get-textual-input-position [PORT])                ; ext
  (guard-continuation GUARDs CONT GUARDs)
  (guard-dynamic-extent GUARDs COMBINER GUARDs)
  (guess-object-name OBJECT BOOLEAN)                 ; ext

  ($if BOOLEAN FORM FORM)
  (ignore? . OBJECTs)
  (immutable-pair? . OBJECTs)
  ($import! ENV . SYMBOLs)
  ($import-library! IMPORT-SPECIFICATIONs)
  (inert? . OBJECTs)
  (input-port? . OBJECTs)
  (integer? . OBJECTs)
  (integer->char INTEGER)
  (integer-length INTEGER)

  (keyword? . OBJECTs)                               ; klisp
  (keyword->string KEYWORD)                          ; klisp
  (keyword->symbol KEYWORD)                          ; klisp

  ($lambda PTREE . BODY)
  ($lazy FORM)
  (lcm . NUMBERs)                                    ; TODO
  (length STRING)
  ($let BINDINGS . BODY)
  ($let* BINDINGS . BODY)
  ($let1 SYMBOL OBJECT . BODY)                       ; ext
  ($let/cc SYMBOL . BODY)
  ($letrec BINDINGS . BODY)
  ($letrec* BINDINGS . BODY)
  ($let-redirect ENV BINDINGS . BODY)
  ($let-safe BINDINGS . BODY)
  (library? . OBJECTs)                               ; klisp
  (library-name-component? . OBJECTs)                ; klisp
  (list . OBJECTs)
  (list* . OBJECTs)
  (list->bytevector LIST)                            ; klisp
  (list->string LIST)
  (list->tabulate N APPLICATIVE)                     ; SRFI-1
  (list->vector LIST)                                ; klisp
  (list-neighbors LIST)
  (list-ref LIST INDEX)
  (list-tail LIST INTEGER)
  (load FILENAME)

  (make-bytevector INTEGER [U8])
  (make-compiled-operative VAR VAR PROGRAM)          ; ext
  (make-encapsulation-type)
  (make-environment . ENVs)
  (make-error-object MESSAGE [IRRITANTS [SOURCE]])   ; ext
  (make-kernel-standard-environment)
  (make-keyed-dynamic-variable)
  (make-keyed-dynamic-variable* DEFAULT-VALUE)       ; ext
  (make-keyed-static-variable)
  (make-library . BINDINGs)                          ; klisp
  (make-list INTEGER [OBJECT])
  (make-string INTEGER [CHAR])
  (make-vector INTEGER [OBJECT])
  (map APPLICATIVE . LISTs)
  ($match OBJECT (PTREE . BODY) ...)                 ; ext
  (max . NUMs)
  (member? OBJECT LIST)
  (memoize OBJECT)
  (memq? OBJECT LIST)
  (min . NUMs)
  (mod INTEGER INTEGER)
  (mod0 INTEGER INTEGER)
  (mutable-pair? . OBJECTs)

  (negate NUM)                                       ; ext
  (negative? . NUMs)
  (newline [PORT])
  (not? BOOLEAN)
  (null? . OBJECTs)
  (number? . OBJECTs)
  (number->string NUMBER [RADIX])                    ; klisp

  (odd? . NUMs)
  (open-binary-input-file FILENAME)
  (open-binary-output-file FILENAME)
  (open-binary-pipe [FLAGS])                         ; ext
  (open-input-file FILENAME)
  (open-input-string STRING)
  (open-output-file FILENAME)
  (open-output-string [INITIAL-BUFFER-SIZE])         ; r7rs ext
  (open-output-bytevector [INITIAL-BUFFER-SIZE])     ; r7rs ext
  (open-utf-decoder PORT)                            ; ext
  (open-utf-encoder PORT)                            ; ext
  (operative? . OBJECTs)
  (or? . BOOLEANs)
  ($or? . FORMs)
  (output-port? . OBJECTs)

  (pair? . OBJECTs)
  (peek-char [PORT])
  (port? . OBJECTs)
  (positive? . NUMs)
  (promise? . OBJECTs)
  ($provide SYMBOLS . BODY)
  ($provide-library! LIBRARY-NAME EXPOR-SPEC BODY)   ; klisp

  ($quote OBJECT)                                    ; ext
  ($quote* . OBJECT)                                 ; ext

  (rdtsc)                                            ; ext
  (read [PORT])
  (read-bytevector [PORT])                           ; ext
  (read-char [PORT])
  (read-edit PROMPT HISTORY COMPLETIONS)             ; ext
  (read-key [PORT])                                  ; ext
  (reduce LIST BIN ID [PRE INT POST])
  ($register-library! LIBRARY-NAME LIBRARY)          ; klisp
  ($registered-library? LIBRARY-NAME)                ; klisp
  (register-requirement! STRING)                     ; klisp
  (registered-requirement? STRING)                   ; klisp
  ($remote-eval FORM ENV)
  (require STRING)                                   ; klisp
  (reverse LIST)                                     ; klisp, r5rs

  ($sequence . FORMs)
  (set! ENV SYMBOL OBJECT)                           ; ext
  ($set! ENV SYMBOL FORM)
  (set-car! PAIR OBJECT)
  (set-cdr! PAIR OBJECT)
  (shared-structure-indicator OBJECT)                ; ext
  (signum NUM)                                       ; ext
  (string? . STRINGs)
  (string<? . STRINGs)
  (string<=? . STRINGs)
  (string=? . STRINGs)
  (string>=? . STRINGs)
  (string>? . STRINGs)
  (string->keyword STRING)                           ; klisp
  (string->list STRING)
  (string->number STRING [RADIX])
  (string->symbol STRING)
  (string-append . STRINGs)
  (string-length STRING)
  (string-ref STRING INDEX)
  (string-size STRING)
  (substring STRING INDEX INDEX)
  (symbol? . OBJECTs)
  (symbol->keyword SYMBOL)                           ; klisp
  (symbol->string SYMBOL)
  (system STRING)                                    ; ext

  (tc-cbreak-noecho BYTEVECTOR)                      ; ext
  (tcgetattr PORT)                                   ; ext
  (tcsetattr PORT BYTEVECTOR)                        ; ext
  (terminal-port? . OBJECTs)                         ; ext
  (textual-port? . OBJECTs)                          ; klisp

  ($unless BOOLEAN . FORMs)                          ; klisp
  ($unregister-library LIBRARY-NAME)                 ; klisp
  (unregister-requirement! STRING)                   ; klisp
  (unwrap APPLICATIVE)

  ($vau PTREE SYMBOL . BODY)
  (vector . OBJECTs)                                 ; klisp, r7rs
  (vector? . OBJECTs)                                ; klisp, r7rs
  (vector->list VECTOR)                              ; klisp, r7rs
  (vector-length VECTOR)                             ; klisp, r7rs
  (vector-ref VECTOR INDEX)                          ; klisp, r7rs
  (vector-set! VECTOR INDEX OBJECT)                  ; klisp, r7rs

  (waitpid [PID [OPTIONS]])                          ; ext
  (with-input-from-file FILENAME COMBINER)
  (with-input-from-port FILENAME COMBINER)
  (with-input-from-string FILENAME COMBINER)         ; ext
  (with-noncanonical-input COMBINER)                 ; ext
  (with-output-to-file FILENAME COMBINER)
  (with-output-to-port FILENAME COMBINER)
  (with-output-to-string COMBINER)                   ; ext
  (with-output-to-bytevector COMBINER)               ; ext
  ($with-printer-flags BINDINGS COMBINER)            ; ext
  (with-signal-handler (SIGSPEC HANDLER) COMBINER)   ; ext
  ($with-subprocess EXECVE-ARGS REDIRECTIONS . BODY) ; ext
  ($with-subshell COMMAND REDIRECTIONS . BODY)       ; ext
  (wrap COMBINER)
  (write OBJECT [PORT])
  (write-bytevector BYTEVECTOR [PORT])               ; klisp
  (write-char CHAR [PORT])
  (write-simple OBJECT [PORT])                       ; klisp, r7rs
  (write-string STRING [PORT])
  (write-utf8-string STRING [PORT])                  ; ext
  (write-utf8-char CHAR [PORT])                      ; ext

  (zero? . NUMs)

Bronze Age Lisp Extensions
--------------------------

 1) type and comparison predicates
    ------------------------------

  (bigint? . OBJECTs)
  (fixint? . OBJECTs)

    Type predicates for internal integer representations.

    Integers of small magnitude are represented by tagged
    values known as fixints. Other integers are represented
    by heap-allocated blocks known as bigints.

    (fixint? x)
      == ($and? (integer? x) (<=? 536870911 x -536870912))))
      == ($and? (integer? x) (<? (integer-length x) 30))

    (bigint? x)
      == ($and? (integer? x) (not? (fixint? x)))

  (bytevector<? . BYTEVECTORs) (bytevector<=? BYTEVECTORS ...)

    Implementation of lexicographic order on bytevectors.

 2) extended standard bindings
    --------------------------

  (make-keyed-dynamic-variable* DEFAULT-VALUE)
      => (BIND ACCESS)

    Like make-keyed-dynamic-variable, but the variable
    is bound to DEFAULT-VALUE in continuations which
    are not descendant of the ones introduced by BIND.

  (set! ENV PTREE OBJECT)
      => #inert

    Fully applicative version of $set!. Evaluates all
    arguments in the dynamic environment, and matches
    PTREE with OBJECT in the environment ENV.

  (file-exists? . STRINGs)

    Return #t if each of the arguments refers to an existing file
    or directory. Bronze Age Lisp supports arbitrary number of
    arguments for the sake of consistency with other predicates.
    Klisp and R7Rs support only one argument in (file-exists? ...).

 3) convenience combiners
    ---------------------

  ($quote OBJECT) => OBJECT
  ($quote* . OBJECT) => OBJECT

    Quoting operatives. Bad style, but useful.

  ($formal-parameter-tree? . OBJECTs)

    Returns #t, if all OBJECTs evaluate to valid formal
    parameter trees. Returns #f otherwise.

  ($let1 SYMBOL OBJECT . BODY)

    Equivalent to ($let ((SYMBOL OBJECT)) . BODY),
    but it is more efficient, because it does not
    need to check validity of general parameter
    trees. Morever, the environment created is
    allocated in the "transient" area of the heap,
    and may be reclaimed more quickly.

  ($match OBJECT . CLAUSEs)

    CLAUSEs must be a list of pairs of the form (PTREE . BODY),
    where each PTREE is a valid formal parameter tree. The
    operative $match evaluates OBJECT in the dynamic environment
    and matches the result against PTREEs. If a matching clause
    is found, the elements of BODY are evaluated in a newly
    created environment with all symbols from the matching
    PTREE. If no matching clause is found, #inert is returned.

  (negate NUM) => NUM

    Equivalent to (- 0 NUM). Note that according
    to the Kernel Report, (- NUM) is an error.

  (signum NUM) => NUM

    Returns 1, 0, or -1, respectively, if NUM
    is positive, zero, or negative, respectively.

  (shared-structure-indicator START-OBJECT)
    => PREDICATE?

    Returns an applicative PREDICATE?, which reveals
    sharing among sub-structures of OBJECT.

      (PREDICATE? X)

    evaluates to #t, if these three conditions hold:

      (i) X appears at two or more places in OBJECT

     (ii) X is a pair, vector or error-object

    (iii) X is reachable from START-OBJECT by following
          - car and cdr fields of pairs,
          - vector elements,
          - message and irritants of error objects

 4) interpreter control and diagnostics
    -----------------------------------

  (collect-garbage)
      => #inert

    Forces garbage collector run.

  (get-performance-statistics)
      => ((#:perf-time ("lisp-gc" . INTEGER)
                       ("blob-gc" . INTEGER)
                       ("equal" . INTEGER)
                       ("check-ptree" . INTEGER)
                       ("system-call" . INTEGER)))

    Returns nested association list with information
    useful for estimating performance of the interpreter.

    The elements defined so far are times (measured
    by RDTSC instruction) spent in various parts
    of the interpreter.

    #:perf-time
      "lisp-gc"     ... GC for structured objects
      "blob-gc"     ... GC for blobs
      "equal"       ... (equal? ...)
      "check-ptree" ... checking validity of parameter trees
      "system-call" ... time spent in system calls

  (make-error-object MESSAGE [IRRITANTS [SOURCE]])

    Creates a new error object without raising the error.

  (error-object-source ERROR-OBJECT)
      => symbol or #inert

    Returns a symbol denoting the built-in combiner
    which raised the error.

  (guess-object-name OBJECT BOOLEAN)
      => symbol or #inert

    Searches the ground environment to determine
    the name of OBJECT. The boolean parameter
    is not used yet.

  (rdtsc)
      => integer (bigint)

    Returns value of the processor time stamp counter.
    (uses RDTSC instruction internally).

  (with-signal-handler (SIGSPEC HANDLER) APPLICATIVE)

    HANDLER must be either applicative, or one of
    the keywords #:default and #:ignore. SIGSPEC
    must be a number or one of the keywords #:sigint,
    #:sigterm, #:sigusr1, #:sigusr2.

    The APPLICATIVE is called with empty parameter tree
    in the dynamic extent of a newly created child C of
    the continuation of (with-signal-handler ...). While
    the program is running in the dynamic extent of C,
    handling of the signal specified by SIGSPEC is determined
    by HANDLER.

    If HANDLER is an applicative and the signal specified
    by SIGSPEC arrives while the interpreter is running]
    in the dynamic extent of C, the current continuation
    C' is captured and HANDLER is called in dynamic extent
    of C', with the signal number as the argument.

    If HANDLER passes a value normally to C', the value
    is discarded and the evaluation of APPLICATIVE
    resumes. If HANDLER passes a value abnormally to
    another continuation, the usual processing of guarded
    continuations takes place.

    If HANDLER is the keyword #:ignore, the signal
    is ignored. If HANDLER is #:default, the default
    signal handling specified by the Linux operating
    system is used (the default usually means
    termination).

    Note that the REPL uses (with-signal-handler ...)
    to catch SIGINT (i.e. Ctrl-C).

 5) low-level input and output

  (close-port-ignore-errors PORT)
      => #inert

    Closes PORT, silently ignoring all errors (including
    type error in PORT argument).

  (dup2 PORT/FIXINT PORT/FIXINT) => #inert

    Interface to dup2() system call. See dup2(2) man page.

  (get-output-bytevector-position PORT)
      => fixint

    Returns number of bytes writen in PORT. Signals
    an error if PORT was not created with
    open-output-bytevector.

    Equivalent to
      (bytevector-length (get-output-bytevector PORT))

  (get-textual-input-position [PORT])
      => (LINE COLUMN)

    Returns line and column number corresponding to the
    current position in the textual input PORT. The position
    may not be reliable if used on terminal port in
    (with-noncanonical-input ...).

  (open-binary-pipe [#:no-cloexec]) => (IN-PORT OUT-PORT)

    Creates a pipe and two unbuffered binary ports associated
    with its read and write ends.

    The pipe is created with the flag O_CLOEXEC (see man pipe(2)),
    unless #:no-cloexec is passed to (open-binary-pipe ...).

  (open-utf-decoder BINARY-INPUT-PORT)
      => TEXTUAL-INPUT-PORT

    Creates a textual input port on top of an existing
    binary input port. UTF-8 encoding is assumed.
    Closing the textual port causes closing of the
    underlying binary port.

  (open-utf-encoder BINARY-OUTPUT-PORT [BUFFER-SIZE])
      => TEXTUAL-OUTPUT-PORT

    Creates a textual output port on top of an existing
    binary output port. UTF-8 encoding is assumed.
    Closing the textual port causes closing of the
    underlying binary port.

  (read-bytevector [PORT])
      => BYTEVECTOR/EOF-OBJECT

    Reads up to ($configured default-buffer-size) bytes from
    a binary input port.

  (write-utf8-string STRING [BINARY-OUTPUT-PORT])
      => #inert

    Writes UTF-8 representation of STRING to
    a binary output port.

  (write-utf8-char CHAR [BINARY-OUTPUT-PORT])
      => #inert

    Writes UTF-8 representation of CHAR to
    a binary output port.

 6) Terminal interface

  (terminal-port? . OBJECTs) => BOOLEAN

    Returns #t, iff all arguments are ports connected
    to a terminal. The function is analogous to POSIX
    function isatty().

    A port created by open-utf-decoder or open-utf-encoder
    is a terminal port, if the underlying binary port
    is a terminal port.

  (tcgetattr PORT) => BYTEVECTOR

    Returns low-level terminal attributes of PORT as
    a bytevector. The function is analogous to
    POSIX function tcgetattr().

  (tcsetattr PORT BYTEVECTOR) => #inert

    Changes low-level terminal attributes of PORT
    according to BYTEVECTOR.

  (tc-cbreak-noecho BYTEVECTOR) => BYTEVECTOR

    Turns off echo and canonical processing. The resulting
    bytevector must be applied to the port by
    (tcsetattr ...). The function is analogous to ncurses
    functions cbreak() and noecho().

  (with-noncanonical-input COMBINER)

    Runs COMBINER with echo and canonical processing
    turned off. The current input and output ports
    must be connected to the same terminal.

    Non-canonical processing is necessary for
    correct function of (char-ready?) and (read-key).

  (read-key [PORT]) => CHARACTER or KEYWORD or LIST

    Reads a character or an ANSI terminal escape
    sequence from PORT. The result is either
    a character, or one of the keywords:

      #:up #:down #:right #left #:home #:end
      #:delete #backspace
      #:tab #:return #:escape

    or a list of characters (the first element
    of the list is #\escape = #\x1B).

    Works with XTERM and linux console. The canonical
    processing on the port should be turned off.

 7) High-level input and output features

  ($get-printer-flag SYMBOL)

    Returns current value of a flag which controls
    the behavior of (write ...). The flags are

      unicode
        #t - print #e+infinity as the infinity sign

        #f - do not use unicode on output

      color
        #t - print parentheses in color using
              ANSI terminal escape sequences
        #f - do not use colors
        #:if-terminal - use colors only if the port
                         is terminal

      share
        #t - show sharing using SRFI-38/R7RS
             datum notation #NN= and #NN# (as write)
        #f - print naively (as write-simple)

      escape
        #t - escape strings and characters (as write)
        #f - do not escape (as display)

  ($with-printer-flags BINDINGS COMBINER)

    Evaluate (COMBINER) with modified printer flags.

  (color-port? PORT)

    Return #t iff (write OBJECT PORT) would print
    in color.

  (read-edit PROMPT HISTORY COMPLETIONS)

    Reads a string with limited editing capabilities.
    This input function is used by the REPL, if the
    input and output ports are connected to terminal.

    PROMPT must be a string and HISTORY and COMPLETIONS
    must be lists of strings.

 8) Process management

  (execve PATH [ARGS [ENVIRON]])

    Replaces the interpreter by the program loaded from PATH.

    The list ARGS of strings is converted to command line
    the argument vector. The list must have at least one element.
    The first element becomes the "program name" argv[0].

    If ENVIRON is not specified or it is equal to #ignore,
    the program inherits the environment from the parent process.
    Otherwise, ENVIRON must be a list of strings of the
    form "NAME=VALUE", and it is passed as an environment to
    the program.

    The form (execve ...) does not return, unless an error occurs.

  (fork APPLICATIVE [CONTINUATION]) => PID / ?

    Creates a new child process using the fork() system
    call. The program proceeds differently in the
    parent and in the child processes.

      - In the parent process, the (fork ...) combination
        returns the process id of the child.

      - In the child process, the APPLICATIVE is called
        on the empty argument list. If CONTINUATION is
        specified, then the call takes place in the
        dynamic extent of CONTINUATION.

    If CONTINUATION is specified, the child executes
    a program equivalent to

      (apply-continuation CONTINUATION (APPLICATIVE))

    except that no continuation guards are invoked. This
    behavior is not consistent with the usual semantics
    of guarded continuations in the Kernel Language. The
    inconsistency was introduced in order to implement
    the typical Unix fork-exec operation. The child
    process can exit() after failed exec() without
    invoking the continuation guards installed in
    the parent process.

  (getpid) => INTEGER

    Returns the process ID of the interpreter.

  (system STRING) => (TYPE CODE)

    Executes STRING as a shell command and waits for its
    completion. Returns (#:exited EXIT-CODE), if the shell
    exits, and (#:signalled SIGNAL-NUMBER), if the shell was
    terminated by a signal.

    Modelled after the POSIX library function system().

    Application notes:

      The errors which may occur while starting the shell or
      executing the command are not propagated to the
      error-continuation of the calling program. Instead, an
      error message is printed on the standard error.

      The program which uses system should flush all ports
      associated with any file descriptor which may be used
      by the shell command.

  (waitpid [PID [#:nohang]]) => (REAL-PID TYPE CODE)

    Wait until a child process terminates. The PID
    is an integer specifying the process ID or
    #:ignore.

    The result is a list (REAL-PID TYPE CODE), where
    REAL-PID is the PID of the process which terminated,
    TYPE is #:exited or #:signalled, and CODE is the
    exit code or signal number associated with the
    termination.

    The form (waitpid PID #:nohang) returns without waiting.
    If no child has exited, the list (#inert #:waiting #inert)
    is returned.

    This function is an interface to Linux system call
    waitpid(). See wait(2) man page for more information.

  ($with-subprocess EXECVE-ARGS REDIRECTIONS . BODY)
      => ((TYPE CODE) RESULT)

    Same as ($with-subshell ...), except that the program
    and its command line and environment is specified
    in the same way as for (execve ...).

    Example:

      ($with-subprocess
        ("/bin/date" (list "date") (list "TZ=XYZ+5"))
        ((stdout f))
        (read-line f))

  ($with-subshell COMMAND REDIRECTIONS . BODY)
      => ((TYPE CODE) RESULT)

    Creates a subprocess to execute COMMAND through the
    operating systems shell and executes BODY in parallel
    with the subprocess. Waits for command completion and
    returns the exit status status (as in (system ...)) and
    result of the last form in BODY.

    The standard input, output and error of the command can
    be redirected to ports accessible in BODY. The argument
    REDIRECTIONS is a list of elements of the form
    (FILESPEC VAR). The symbol VAR is bound to a port
    associated with a pipe connected to FILESPEC.

      FILESPEC          bind VAR to a port connected to
      ---------------------------------------------------------
      stdin         ... standard input of the command (textual)
      binary-stdin  ... standard input (binary unbuffered)
      stdout        ... standard output (textual)
      binary-stdout ... standard output (binary unbuffered)
      stderr        ... standard output (textual)
      stdout+stderr ... standard output and standard error (textual)

    The port objects bound to VAR can be closed inside BODY
    using an applicative which is bound to the symbol
    close-pipe.

    Example: Compute MD5 checksum of a string using unix commands.

      ($define! md5
        ($lambda (s)
          ($define! (status result)
            ($with-subshell
              "md5sum - | cut -d' ' -f1"
              ((stdin f) (stdout g))
              (write-string s f)
              (close-pipe f)
              (read-line g)))
          ($if (equal? status (list #:exited 0))
            result
            (error "md5sum failed" status))))

 9) Native code generator

  (make-compiled-operative ARG-VAR ENV-VAR PROGRAM)

    Compile the imperative PROGRAM and return the result as an
    operative combiner.

    More doc TODO (for now, see src/modules/native-interfaces.k)

  (disassemble-compiled-combiner COMBINER)

    Print disassebmled native code of COMBINER, where COMBINER was
    created by (make-compiled-operative ...).

    Uses the "ndisassm" command line utility from the NASM package.
    The utility must be installed in $PATH.

Part II - REPL
==============

Command line arguments
----------------------

  Command line usage is mostly compatible with klisp:

  bronze.bin [OPTIONS] [SCRIPT.k [SCRIPT-ARGS]]

  -e EXPR        evaluate EXPR

  -l FILE        load FILE and continue processing arguments,
                 equivalent to -e '(load "FILE")'

  -r FILE        require a FILE and continue processing arguments,
                 equivalent to -e '(require "FILE")'

  -i             force interactive REPL

  -b             disable color output and line editing in REPL
                 equivalent to -e '($define! %dumb #t)'

  -              read expressions from STDIN and evaluate
                 one-by-one

  -v, --version  print version string
  -h, --help     print short help

Environment variables
---------------------

  KLISP_PATH

Special bindings in Read-Eval-Print Loop
----------------------------------------

  %         the last result printed by REPL

  %history  list of strings recently entered in REPL

  %dumb     bound to #t if the interpreter was run
            with the option -b

Keyboard shortcuts
------------------

  UP/DOWN  - move in command history
  TAB      - very limited completion
  Ctrl-D   - erase the line
  Ctrl-C   - interrupt and return to the REPL

  If the input line contains more than one
  object, and the first object is a symbol,
  the interpreter adds parentheses automatically,
  for example, the input

    $define x 1 <ENTER>

  is replaced by

    ($define x 1)

  and evaluated.

Part III - Build Configuration
==============================

  src-prefix = ""
    Path to lisp sources of the interpreter relative
    to working directory where the bootstrapping
    interpreter is run.

    The path must be specified if the bootstrapping
    is done outside of the src/ directory. For example,
    see tst/test.sh.

  asm-prefix = ""
    Path to assembler sources of the interpreter,
    relative to working directory of the assembler.

  lisp-heap-size = (* 2 1024 1024)
    Capacity of lisp heap (bytes, power of two).

    The interpreter manages two heaps. One for
    structured objects (cons cells, continuations,
    vectors, ...) and one for blobs.

    Warning: Making the heap larger does not
    necessarily make the program faster.

    Some algorithms of the interpreter (most importantly,
    equal? and checking for cycles in parameter trees) need
    a mark bit for each object. The mark bits are stored
    in the unused halfspace of the copying colector. All
    mark bits must be cleared before use, and this
    operation costs O(heap capacity).

  blob-descriptor-capacity = 8192
    Size of blob heap descriptor table (entries).

    This value represents the maximal number of
    blobs the interpreter can hold.

  blob-heap-size = (* 512 1024)
    Size of blob heap (bytes).

    This value represents the sum of lengths of
    blobs the interpreter can hold.

  signal-ring-capacity = 16
    Capacity of ring buffer for information on caught
    signals.

    A signal may arrive asynchronously when the
    interpreter executes native code (e.g. the garbage
    collector or implementation of bigint arithmetic).
    The information about the signal is stored in
    auxilliary buffer, until the interpreter is ready
    to hand it to the lisp code.

  lisp-transient-size = (* 16 1024)
    Size of transient area in the lisp heap (bytes).

    The transient area is used for helper continuations
    when evaluation arguments of applicative combiners,
    and also for environments created by $let1. The
    space used by continuations and environments in
    the transient area may be reclaimed quickly after
    the objects die, if the objects are not captured
    (i.e. stored in another objects, namely environments).

    TODO: Optimal size of transient area.

  lisp-heap-threshold = (* 17 1024)
    Allocation threshold (bytes).

    When the free heap drops below this limit,
    garbage collector is run. The threshold must
    be greater than lisp-transient-size.

 The following configuration parameters are
 used only for testing and debugging the interpreter.

  start-form = ($quote (stand-alone-interpreter))
    Object evaluated after the interpreter starts up.

  user-ground-bindings = ()
    Additional ground bindings
    (overengineering, never used that)

  no-applicative-support = #f
    Do not generate applicative support code (testing only).

  no-macros = #f
    Do not output assembler macros and constants (testing only).

  no-code-segment = #f
    Do not output code segment (testing only).

  no-data-segment = #f
    Do not output data segments (testing only).

  debug-continuations = #f
    Enables debugging messages in continuations.

  debug-ports = #f
    Enables debugging messages in the ports module.

  debug-environments = #f
    Enables debugging messages in environments.

  debug-gc-blobs = #f
    Enables debugging messages blob GC.

  debug-gc-detail = #f
    Enables detailed debugging messages in the garbage collector.

  debug-gc-cycle = #f
    Enables debugging message about free heap after GC cycle.

  debug-evaluator = #f
    Enables debugging messages in the evaluator.

  character-predicates = #t
    Enable (char-alphabetic?).

  reader-and-printer = #t
    Enable (read), (write).

  default-buffer-size = 256
    Default buffer size for textual ports.

  raw-stdio = #f
    Binary input/output/error ports.

  stdio = #t
    Enable ports and standard input/output/error ports.
